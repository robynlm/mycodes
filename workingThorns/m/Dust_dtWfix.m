SetEnhancedTimes[False];

(******************************************************************************)
(******************************************************************************)
(******************************************************************************)
(* Options *)
(******************************************************************************)
(******************************************************************************)
(******************************************************************************)

derivOrder = 4;
maxTimelevels = 4;

prefix = "CT_";
suffix = "" <> If [derivOrder!=4, "_O" <> ToString[derivOrder], ""];

CTThorn = prefix <> "Dust" <> suffix;

(******************************************************************************)
(******************************************************************************)
(******************************************************************************)
(* Derivatives *)
(******************************************************************************)
(******************************************************************************)
(******************************************************************************)

KD = KroneckerDelta;

derivatives =
{
  PDstandardNth[i_]    -> StandardCenteredDifferenceOperator[1,fdOrder/2,i],
  PDstandardNth[i_,i_] -> StandardCenteredDifferenceOperator[2,fdOrder/2,i],
  PDstandardNth[i_,j_] -> StandardCenteredDifferenceOperator[1,fdOrder/2,i] *
                          StandardCenteredDifferenceOperator[1,fdOrder/2,j],
  PDdissipationNth[i_] ->
    spacing[i]^(fdOrder+1) / 2^(fdOrder+2) *
    StandardCenteredDifferenceOperator[fdOrder+2,fdOrder/2+1,i],
  
(* PD: These come from my mathematica notebook
   "Upwind-Kranc-Convert.nb" that converts upwinding finite
   differencing operators generated by
   StandardUpwindDifferenceOperator into this form *)

  Sequence@@Flatten[Table[
   {PDupwindNth[i] -> Switch[fdOrder,
      2, (dir[i]*(-3 + 4*shift[i]^dir[i] - shift[i]^(2*dir[i])))/(2*spacing[i]),
      4, (dir[i]*(-10 - 3/shift[i]^dir[i] + 18*shift[i]^dir[i] -
          6*shift[i]^(2*dir[i]) + shift[i]^(3*dir[i])))/(12*spacing[i]),
      6, (dir[i]*(-35 + 2/shift[i]^(2*dir[i]) - 24/shift[i]^dir[i] 
                  + 80*shift[i]^dir[i] - 30*shift[i]^(2*dir[i])
                  + 8*shift[i]^(3*dir[i])
                  - shift[i]^(4*dir[i])))/(60*spacing[i]),
      8, (dir[i]*(-378 - 5/shift[i]^(3*dir[i]) + 60/shift[i]^(2*dir[i]) 
                  - 420/shift[i]^dir[i] + 1050*shift[i]^dir[i]
                  - 420*shift[i]^(2*dir[i]) + 140*shift[i]^(3*dir[i])
                  - 30*shift[i]^(4*dir[i])
                  + 3*shift[i]^(5*dir[i])))/(840*spacing[i])],

    PDupwindNthAnti[i] -> Switch[fdOrder,
      2, (+1 shift[i]^(-2) -4 shift[i]^(-1) +0 shift[i]^( 0) +4 shift[i]^(+1) 
          -1 shift[i]^(+2)) / (4 spacing[i]),
      4, (-1 shift[i]^(-3) +6 shift[i]^(-2) -21 shift[i]^(-1 )
          +0 shift[i]^( 0) +21 shift[i]^(+1)
          -6 shift[i]^(+2) +1 shift[i]^(+3)) / (24 spacing[i]),
      6, (+1 shift[i]^(-4) -8 shift[i]^(-3) +32 shift[i]^(-2) 
          -104 shift[i]^(-1) +0 shift[i]^( 0)
          +104 shift[i]^(+1) -32 shift[i]^(+2) +8 shift[i]^(+3) 
          -1 shift[i]^(+4)) / (120 spacing[i]),
      8, (-3 shift[i]^(-5) +30 shift[i]^(-4) -145 shift[i]^(-3) 
          +480 shift[i]^(-2) -1470 shift[i]^(-1)
          +0 shift[i]^( 0) +1470 shift[i]^(+1) -480 shift[i]^(+2) 
          +145 shift[i]^(+3) -30 shift[i]^(+4)
          +3 shift[i]^(+5)) / (1680 spacing[i])],

    PDupwindNthSymm[i] -> Switch[fdOrder,
     2, (-1 shift[i]^(-2) +4 shift[i]^(-1) -6 shift[i]^( 0) 
         +4 shift[i]^(+1) -1 shift[i]^(+2)) / (4 spacing[i]),
     4, (+1 shift[i]^(-3) -6 shift[i]^(-2) +15 shift[i]^(-1) 
         -20 shift[i]^( 0) +15 shift[i]^(+1)
         -6 shift[i]^(+2) +1 shift[i]^(+3)) / (24 spacing[i]),
     6, (-1 shift[i]^(-4) +8 shift[i]^(-3) - 28 shift[i]^(-2)
         +56 shift[i]^(-1)-70 shift[i]^( 0)
         +56 shift[i]^(+1) -28 shift[i]^(+2) +8 shift[i]^(+3) 
         -1 shift[i]^(+4)) / (120 spacing[i]),
     8, (+3 shift[i]^(-5) -30 shift[i]^(-4) +135 shift[i]^(-3) 
         -360 shift[i]^(-2) +630 shift[i]^(-1)
         -756 shift[i]^( 0) +630 shift[i]^(+1) -360 shift[i]^(+2) 
         +135 shift[i]^(+3) -30 shift[i]^(+4)
         +3 shift[i]^(+5)) / (1680 spacing[i])],

    (* TODO: make these higher order stencils *)
    PDonesided[i] -> dir[i]*(-1 + shift[i]^dir[i])/spacing[i]} /. i->j, {j,1,3}
  ],1]
};

PD = PDstandardNth;

If [splitUpwindDerivs,
    Upwind[dir_, var_, idx_] := dir PDua[var,idx] + Abs[dir] PDus[var,idx],
    Upwind[dir_, var_, idx_] := dir PDu[var,idx]];

(******************************************************************************)
(******************************************************************************)
(******************************************************************************)
(* Tensors *)
(******************************************************************************)
(******************************************************************************)
(******************************************************************************)

(* Register the tensor quantities with the TensorTools package *)
Map [DefineTensor,
     {DD, EE, SS, 
      rho, eps, press, wlorentz, u, v,
      T, T0, t, t0,
      g, gu, detg, k, a, b, dir,
      dtS, SaSbdgab, SSloc, Sstress,
      dsgu, dta, dtb, dtg, dtgu
}];

Map [AssertSymmetricIncreasing,
     {g[la,lb], T[la,lb], k[la,lb], sigmass[la,lb]}];
Map [AssertSymmetricIncreasing,
     {gu[ua,ub]}];

(* Use the CartGrid3D variable names *)
x1=x; x2=y; x3=z;

(* ADMBase variables *)
g11=gxx; g12=gxy; g22=gyy; g13=gxz; g23=gyz; g33=gzz;
a=alp;
b1=betax; b2=betay; b3=betaz;
dta=dtalp;
dtb1=dtbetax; dtb2=dtbetay; dtb3=dtbetaz;
k11=kxx; k12=kxy; k22=kyy; k13=kxz; k23=kyz; k33=kzz;

(* HydroBase variables *)
v1=velx; v2=vely; v3=velz;

(* TmunuBase variables *)
T00=eTtt;
T01=eTtx; T02=eTty; T03=eTtz;
T11=eTxx; T12=eTxy; T22=eTyy; T13=eTxz; T23=eTyz; T33=eTzz;

(******************************************************************************)
(******************************************************************************)
(******************************************************************************)
(* Expressions *)
(******************************************************************************)
(******************************************************************************)
(******************************************************************************)

pi = N[Pi,40];

detgExpr  = Det [MatrixOfComponents [g [la,lb]]];

(******************************************************************************)
(******************************************************************************)
(******************************************************************************)
(* Groups *)
(******************************************************************************)
(******************************************************************************)
(******************************************************************************)

(* Define a group and declare its name *)
DefineGroup1[name_, tensor_, timelevels_:1] :=
  Module[{group},
         group = CreateGroupFromTensor[tensor];
         group = AddGroupExtra[group, Timelevels -> timelevels];
         group = SetGroupName[group, name];
         group];
       
evolvedGroups =
   {DefineGroup1[prefix <> "D", DD    , maxTimelevels],
    DefineGroup1[prefix <> "E", EE    , maxTimelevels],
    DefineGroup1[prefix <> "S", SS[la], maxTimelevels]};

evaluatedGroups =
   {SetGroupName [CreateGroupFromTensor [Theta         ], prefix <> "Theta"],
    SetGroupName [CreateGroupFromTensor [sigmatt       ], prefix <> "sigmatt"],
    SetGroupName [CreateGroupFromTensor [sigmats[la]   ], prefix <> "sigmats"],
    SetGroupName [CreateGroupFromTensor [sigmass[la,lb]], prefix <> "sigmass"]};
(*
evaluatedGroups =
   {DefineGroup1[prefix <> "Theta"  , Theta          , maxTimelevels],
    DefineGroup1[prefix <> "sigmatt", sigmatt        , maxTimelevels],
    DefineGroup1[prefix <> "sigmats", sigmats[la]    , maxTimelevels],
    DefineGroup1[prefix <> "sigmass", sigmass[la,lb] , maxTimelevels]};
*)

declaredGroups = Join [evolvedGroups, evaluatedGroups];
declaredGroupNames = Map [First, declaredGroups];

inheritedImplementations =
  {"ADMBase", "TmunuBase", "HydroBase"};

extraGroups =
  {{"Grid::coordinates", {x, y, z, r}},
   {"ADMBase::metric",  {gxx, gxy, gxz, gyy, gyz, gzz}},
   {"ADMBase::lapse",   {alp}},
   {"ADMBase::dtlapse", {dtalp}},
   {"ADMBase::shift",   {betax, betay, betaz}},
   {"ADMBase::dtshift", {dtbetax, dtbetay, dtbetaz}},
   {"ADMBase::curv",    {kxx, kxy, kxz, kyy, kyz, kzz}},
   {"HydroBase::rho",       {rho}},
   {"HydroBase::press",     {press}},
   {"HydroBase::eps",       {eps}},
   {"HydroBase::w_lorentz", {wlorentz}},
   {"HydroBase::vel",       {velx, vely, velz}},
   {"TmunuBase::stress_energy_scalar", {eTtt}},
   {"TmunuBase::stress_energy_vector", {eTtx, eTty, eTtz}},
   {"TmunuBase::stress_energy_tensor", {eTxx, eTxy, eTxz, eTyy, eTyz, eTzz}}
};

groups = Join [declaredGroups, extraGroups];

(******************************************************************************)
(******************************************************************************)
(******************************************************************************)
(* Initial data *)
(******************************************************************************)
(******************************************************************************)
(******************************************************************************)

initialMinkowskiCalc =
{
  Name -> CTThorn <> "_Minkowski",
  Schedule -> {"IN HydroBase_Initial"},
  ConditionalOnKeyword -> {"my_initial_data", "Minkowski"},
  Equations -> 
  {
    a  -> 1,
    b1 -> 0,
    b2 -> 0,
    b3 -> 0,
    g11 -> 1,
    g12 -> 0,
    g13 -> 0,
    g22 -> 1,
    g23 -> 0,
    g33 -> 1,
    k11 -> 0,
    k12 -> 0,
    k13 -> 0,
    k22 -> 0,
    k23 -> 0,
    k33 -> 0,
    rho -> 0,
    eps -> 0,
    press -> 0,
    v[ua] -> 0,
    wlorentz -> 1
  }
};

initialFLRWCalc =
{
  Name -> CTThorn <> "_FLRW",
  Schedule -> {"IN HydroBase_Initial"},
  ConditionalOnKeyword -> {"my_initial_data", "FLRW"},
  Shorthands -> {a2, aa, HH},
  Equations -> 
  {
    HH -> "pflrw_H0" "pflrw_t0" / t,
    aa -> "pflrw_a0" ( t / "pflrw_t0" )^(2/(3 (1 + eosw))),
    a2 -> aa^2,

    a -> 1,
    b1 -> 0,
    b2 -> 0,
    b3 -> 0,
    g11 -> a2,
    g12 -> 0,
    g13 -> 0,
    g22 -> a2,
    g23 -> 0,
    g33 -> a2,
    k11 -> - a2 HH,
    k12 -> 0,
    k13 -> 0,
    k22 -> - a2 HH,
    k23 -> 0,
    k33 -> - a2 HH,
    rho -> 3 HH^2 / (8 Pi),
    eps -> 0,
    press -> eosw rho,
    v[ua] -> 0,
    wlorentz -> 1
  }
};

(******************************************************************************)
(******************************************************************************)
(******************************************************************************)
(* Fluid evolution *)
(******************************************************************************)
(******************************************************************************)
(******************************************************************************)

(******************************************************************************)
(* Convert from primitives *)
(******************************************************************************)
convertFromPrimitivesCalc =
{
  Name -> CTThorn <> "_convertFromPrimitives",
  Schedule -> {"IN HydroBase_Prim2ConInitial"},
  ConditionalOnKeyword -> {"formalism", "Wilson"},
  Shorthands -> {detg, h, u0u, u[la], W},
  Equations ->
  {
    detg -> detgExpr,
    h -> (1 + eps) (1 + eosw),
    u0u -> wlorentz / a,
    u[la] -> wlorentz g[la,lb] v[ub],
    W  -> wlorentz Sqrt[detg],
    DD -> W rho,
    EE -> W rho eps,
    SS[la] -> W rho h u[la]
  }
};
(************)
(*
u[la]   4-velocity of fluid
v[ua] 3-velocity of fluid normalised as
  v[la] = u[la] / wlorentz
  v[ua] = (u[ua] / wlorentz) + (b[ua] / a)
          = gu[ua,ub] u[lb] / wlorentz
*)
(************)
       
convertFromPrimitivesCalcVal =
{
  Name -> CTThorn <> "_convertFromPrimitivesVal",
  Schedule -> {"IN HydroBase_Prim2ConInitial"},
  ConditionalOnKeyword -> {"formalism", "Valencia"},
  Shorthands -> {h},
  Equations ->
  {
    wlorentz -> 1 / Sqrt[g[la,lb] v[ua] v[ub] + 1],
    h -> (1 + eps) (1 + eosw),
    DD -> rho wlorentz,
    EE -> rho h wlorentz^2 - press,
    SS[la] -> rho h wlorentz g[la,lb] v[ub]
  }
};

(******************************************************************************)
(* Convert to primitives *)
(******************************************************************************)

convertToPrimitivesCalc =
{
  Name -> CTThorn <> "_convertToPrimitives",
  Schedule -> {"IN HydroBase_Con2Prim"},
  ConditionalOnKeyword -> {"formalism", "Wilson"},
  Where -> Everywhere,
  Shorthands -> {detg, gu[ua,ub], u0u, h, u[la]},
  Equations ->
  {
    detg      -> detgExpr,
    gu[ua,ub] -> 1/detg detgExpr MatrixInverse [g[ua,ub]],
    eps       -> EE / DD,
    h         -> (1 + eps) (1 + eosw),
    u[la]     -> SS[la] / (DD h),
    wlorentz -> Sqrt[gu[ua,ub] u[la] u[lb] + 1],
    v[ua]     -> gu[ua,ub] u[lb] / wlorentz,
    rho       -> DD / (wlorentz Sqrt[detg]),
    press     -> eosw rho (1 + eps)
  }
};
       
convertToPrimitivesCalcVal =
{
  Name -> CTThorn <> "_convertToPrimitivesVal",
  Schedule -> {"IN HydroBase_Con2Prim"},
  ConditionalOnKeyword -> {"formalism", "Valencia"},
  Where -> Everywhere,
  Shorthands -> {detg, gu[ua,ub], EEloc, SSloc[la], S2, mu, u[la]},
  Equations ->
  {
    (* Need to go through this again *)
    detg      -> detgExpr,
    gu[ua,ub] -> 1/detg detgExpr MatrixInverse [g[ua,ub]],
      
    (* conservated variable without gdet *)
    EEloc -> EE / Sqrt[detg],
    SSloc[la] -> SS[la] / Sqrt[detg],
    S2 -> gu[ua,ub] SSloc[la] SSloc[lb],
      
    (* pressure *)
    press -> (EEloc ( eosw - 1 ) + Sqrt[EEloc^2 ( eosw + 1 )^2 - 4 S2 eosw])/2,
    mu    -> press / eosw,
    eps   -> 0.0, (* neglect *)
    rho   -> mu / (1 + eps),
      
    (* fluid velocity *)
    wlorentz -> Sqrt[(EEloc + press) / (mu + press)],
    u[la] -> SSloc[la] / ((mu + press) wlorentz),
    v[ua] -> gu[ua,ub] u[lb] / wlorentz
  }
};

(******************************************************************************)
(* Evolution equations *)
(******************************************************************************)

evolCalc =
{
  Name -> CTThorn <> "_RHS",
  Schedule -> {"IN HydroBase_RHS"},
  ConditionalOnKeyword -> {"formalism", "Wilson"},
  Where -> InteriorNoSync,
    Shorthands -> {dir[ua], detg, gu[ua,ub], trK, h,
        u[la], u0u, u0l, dtwlorentz, W, dtW,
        dtD, dtS[la], SS0u, SS0l, SaSbdgab[la],
        dsgu[la,ub,uc], dtgu[ua,ub],
        dtsgdet, W2m1, W2m1oDpE, PDEV, PDWV, dtwlorentz},
  Equations ->
  {
    dir[ua] -> Sign[b[ua]],

    detg      -> detgExpr,
    gu[ua,ub] -> 1/detg detgExpr MatrixInverse [g[ua,ub]],
    trK       -> gu[ua,ub] k[la,lb],
    u0u       -> wlorentz / a,
    u[la]     -> g[la,lb] v[ub] wlorentz,
    u0l       -> -a^2 u0u + b[ua] u[la],
    h         -> (1 + eps) (1 + eosw),
    W         -> wlorentz Sqrt[detg],
    SS0u      -> W rho h u0u,
    SS0l      -> W rho h u0l,

    (* dt of D *)
    dtD -> - PD[DD (a v[ua] - b[ua]), la],
    dot[DD] -> dtD,
      
    (* dt of S[la] *)
    dsgu[la,ub,uc] -> PD[MatrixInverse[g[ub,uc]], la],
    SaSbdgab[la] -> SS0l SS0l PD[-1/a^2, la]
                    + 2 SS0l SS[lc] PD[b[uc]/a^2, la]
                    + SS[lb] SS[lc] dsgu[la,ub,uc],
    dtS[la] -> - PD[SS[la] (a v[ub] - b[ub]), lb]
               - SaSbdgab[la] / (2 SS0u)
               - a Sqrt[detg] PD[press, la],
    dot[SS[la]] -> dtS[la],
      
    (* dt of metric *)
    dtgu[ua,ub] -> b[uc] dsgu[lc,ua,ub]
                   - PD[b[ua], lc] gu[uc,ub]
                   - PD[b[ub], lc] gu[ua,uc]
                   - 2 a gu[ua,uc] gu[ub,ud] k[lc,ld],
    dtsgdet -> sqrt[detg] ( - a trK + PD[b[ua], la]
                           + (PD[Sqrt[detgExpr] b[ub], lb] / Sqrt[detgExpr])),
      
    (* dt of lorentz factor *)
    W2m1 -> wlorentz^2 - 1,
    W2m1oDpE -> W2m1 / (DD + EE),
    PDEV -> PD[EE (a v[ua] - b[ua]), la],
    PDWV -> PD[wlorentz Sqrt[detgExpr] (a v[ua] - b[ua]), la],
    dtwlorentz -> ((W2m1 (dtgu[ua,ub] SS[la] SS[lb]
                          + 2 gu[ua,ub] SS[la] dtS[lb])
                    / (2 wlorentz gu[ua,ub] SS[la] SS[lb]))
                   - (W2m1oDpE / W) (dtD - PDEV - press PDwlorV)
                   + press W2m1oDpE dtsgdet)
                  / ( 1 - (press sgdet W2m1oDpE / wlorentz )),
      
    (* dt of E *)
    dtW -> (sqrt[detg] dtwlorentz + dtsgdet wlorentz),
    dot[EE] -> (- PDEV - press dtW - press PDWV)
  }
};
       
evolCalcVal =
{
  Name -> CTThorn <> "_RHSVal",
  Schedule -> {"IN HydroBase_RHS"},
  ConditionalOnKeyword -> {"formalism", "Valencia"},
  Where -> InteriorNoSync,
  Shorthands -> {dir[ua], detg, gu[ua,ub], mu, Sstress[ua,ub]},
  Equations ->
  {
      (* Need to go through this again *)
    dir[ua] -> Sign[b[ua]],

    detg      -> detgExpr,
    gu[ua,ub] -> 1/detg detgExpr MatrixInverse [g[ua,ub]],
      
    mu -> rho (1 + eps),
      
    Sstress[ua,ub] -> (mu + press) wlorentz^2 v[ua] v[ub] + press gu[ua,ub],

    dot[DD] -> 0.0, (* neglect *)
    dot[SS[la]] -> (- PD[a detgExpr g[la,lc] 
                         ((rho (1 + eps) + press) wlorentz^2 v[ub] v[uc]
                          + press MatrixInverse[g[ub,uc]]), lb]
                    + PD[b[ub] SS[la], lb]
                    + a Sqrt[detg] Sstress[ub,uc] PD[g[lb,lc], la] / 2
                    + SS[lb] PD[b[ub], la]
                    - EE PD[a, la]),
    dot[EE] -> (- PD[a MatrixInverse[g[ub,uc]] SS[lc], lb]
                + PD[b[ub] EE, lb]
                + a Sqrt[detg] Sstress[ub,uc] k[lb,lc]
                - gu[ub,uc] SS[lc] PD[a, lb])
  }
};

RHSStaticBoundaryCalc =
{
  Name -> CTThorn <> "_RHSStaticBoundary",
  Schedule -> {"IN HydroBase_Boundaries"},
  ConditionalOnKeyword -> {"my_rhs_boundary_condition", "static"},
  Where -> Boundary,
  Equations -> 
  {
    dot[DD]       -> 0,
    dot[EE]       -> 0,
    dot[SS[la]]   -> 0
  }
};

(* Initialise the RHS variables in analysis in case they are going to
   be output - the noninterior points cannot be filled, so we define
   them to be zero *)
initRHSCalc =
{
  Name -> CTThorn <> "_InitRHS",
  Schedule -> {"IN HydroBase_RHS BEFORE " <> CTThorn <> "_RHS"},
  Where -> Everywhere,
  Equations -> 
  {
    dot[DD]       -> 0,
    dot[EE]       -> 0,
    dot[SS[la]]   -> 0
  }
};

(******************************************************************************)
(* Populate the energy-momentum tensor *)
(******************************************************************************)

addToTmunuCalc =
{
  Name -> CTThorn <> "_addToTmunu",
  Schedule -> {"IN AddToTmunu"},
  ConditionalOnKeyword -> {"coupling", "yes"},
  Where -> Everywhere,
  Shorthands -> {detg, gu[ua,ub], u0u, u[la], u0l, bsq, mu},
  Equations ->
  {
    detg      -> detgExpr,
    gu[ua,ub] -> 1/detg detgExpr MatrixInverse [g[ua,ub]],
    u0u       -> wlorentz / a,
    bsq       -> g[la,lb] b[ua] b[ub],
    u[la]     -> g[la,lb] v[ub] wlorentz,
    u0l       -> -a^2 u0u + b[ua] u[la],
    mu        -> rho ( 1 + eps),

    T00       -> ((mu + press) u0l^2 
                  + (press - Lambda/(8 Pi)) (- a^2 + bsq)),
    T0[la]    -> ((mu + press) u0l u[la] 
                  + (press - Lambda/(8 Pi)) g[la,lb] b[ub]),
    T[la,lb]  -> ((mu + press) u[la] u[lb] 
                  + (press - Lambda/(8 Pi)) g[la,lb])
  }
};

(******************************************************************************)
(* Boundary conditions *)
(******************************************************************************)

boundaryCalc =
{
  Name -> CTThorn <> "_boundary",
  Schedule -> {"IN HydroBase_Boundaries"},
  ConditionalOnKeyword -> {"my_boundary_condition", "Minkowski"},
  Where -> Boundary,
  Equations -> 
  {
    DD         -> 0,
    EE         -> 0,
    SS[la]     -> 0
  }
};

(******************************************************************************)
(******************************************************************************)
(******************************************************************************)
(* Parameters *)
(******************************************************************************)
(******************************************************************************)
(******************************************************************************)


extendedKeywordParameters =
{
  {
    Name -> "ADMBase::initial_data",
    AllowedValues -> {CTThorn}
  },
  {
    Name -> "ADMBase::initial_lapse",
    AllowedValues -> {CTThorn}
  },
  {
    Name -> "ADMBase::initial_shift",
    AllowedValues -> {CTThorn} 
  }
};

keywordParameters =
{
  {
    Name -> "my_initial_data",
    Visibility -> "restricted",
    AllowedValues -> {"Minkowski", "FLRW"},
    Default -> "Minkowski"
  },
  {
    Name -> "formalism",
    Visibility -> "restricted",
    Description -> "Wilson for dust and Valencia for radiation",
    AllowedValues -> {"Wilson", "Valencia"},
    Default -> "Wilson"
  },
  {
    Name -> "my_rhs_boundary_condition",
    Visibility -> "restricted",
    AllowedValues -> {"none", "static", "radiative"},
    Default -> "none"
  },
  {
    Name -> "my_boundary_condition",
    AllowedValues -> {"none", "Minkowski"},
    Default -> "none"
  },
  {
    Name -> "coupling",
    AllowedValues -> {"yes", "no"},
    Default -> "no"
  }
};

intParameters =
{
  {
    Name -> nmodes,
    Description -> "Number of Fourier modes in each direction", 
    Default -> 0
  },
  {
    Name -> fdOrder,
    Default -> derivOrder,
    AllowedValues -> {2,4,6,8}
  }
};

realParameters =
{
  {
    Name -> eosw,
    Description -> "Ratio of pressure to density",
    Default -> 0
  },
  {
    Name -> Lambda,
    Description -> "Cosmological constant",
    Default -> 0
  },
  {
    Name -> "pflrw_t0",
    Description -> "Initial time in FLRW models",
    Default -> 1
  },
  {
    Name -> "pflrw_a0",
    Description -> "Initial value of the scale factor in FLRW models",
    Default -> 1
  },
  {
    Name -> "pflrw_H0",
    Description -> "Initial value of the Hubble rate in FLRW models",
    Default -> 1
  }
};

(******************************************************************************)
(******************************************************************************)
(******************************************************************************)
(* Construct the thorns *)
(******************************************************************************)
(******************************************************************************)
(******************************************************************************)

calculations =
{
  initialMinkowskiCalc,
  initialFLRWCalc,
  convertFromPrimitivesCalc,
  convertFromPrimitivesCalcVal,
  evolCalc,
  evolCalcVal,
  initRHSCalc,
  RHSStaticBoundaryCalc,
  boundaryCalc,
  convertToPrimitivesCalc,
  convertToPrimitivesCalcVal,
  addToTmunuCalc,
  calcExpansion,
  calcExpansionBoundary
};

CreateKrancThornTT [groups, ".", CTThorn,
  Calculations -> calculations,
  DeclaredGroups -> declaredGroupNames,
  PartialDerivatives -> derivatives,
  EvolutionTimelevels -> maxTimelevels,
  DefaultEvolutionTimelevels -> Min[3,maxTimelevels],
  UseJacobian -> True,
  UseLoopControl -> True,
  UseVectors -> False,
  InheritedImplementations -> inheritedImplementations,
  ExtendedKeywordParameters -> extendedKeywordParameters,
  KeywordParameters -> keywordParameters,
  IntParameters -> intParameters,
  RealParameters -> realParameters
];
